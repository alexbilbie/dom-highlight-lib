{"version":3,"sources":["../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/Highlighter.ts","../../src/Highlight.tsx","../../src/Highlights.tsx","../../src/utils/isRectPartiallyVisible.ts","../../src/utils/trimInvisibleChars.ts","../../src/utils/getTextNodes.ts","../../src/utils/isElementVisible.ts","TokenView.tsx","index.tsx","../../src/start.tsx"],"names":["_Pact","result","state","this","callback","_settle","e","value","_this","onFulfilled","onRejected","pact","observer","_isSettledPact","thenable","Symbol","Highlighter","minBatchTextLength","getTextNodes","match","matches","groupNodes","oldMatchMap","it","unchanged","changedAndNew","nodes","node","nodeValue","nodeValueHash","stringHash","oldMatch","tokens","ranges","l","items","batch","batchTextLength","i","test","update","body","shouldContinue","stage","updateValue","reject","_resumeAfterBody","_resumeAfterTest","n","j","tokenGroups","m","r","console","updateHighlights","t","document","makeRange","Highlight","token","rect","onMouseEnter","onMouseLeave","style","position","top","left","width","height","borderBottom","zIndex","UPDATE_HANDLER","Highlights","highlighter","throttleUpdates","onMouseEnterItem","onMouseLeaveItem","useState","count","setCount","useEffect","window","type","v","uu","throttle","MutationObserver","args","mutationObserver","attributes","childList","subtree","React","Array","key","mi","isRectPartiallyVisible","right","bottom","vw","vh","REGEX_LEADING_TRAILING_CONTROL_CHARS","trimInvisibleChars","s","selectors","ignoreInvisibleNodes","minTextLength","docE","root","walker","NodeFilter","text","trim","parentElement","findAllTextNodes","TokenView","data","className","background","color","id","keyword","radomColor","colors","Math","floor","random","length","paragraphs","regex","str","localStorage","getItem","RegExp","getRegExp","Promise","resolve","tokenize","exec","push","toString","start","index","end","setTimeout","map","App","setData","showToken","hideToken","highlights","render","Fragment","onClick","div","createElement","innerHTML","appendChild","padding","margin"],"mappings":"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","file":"static/js/main.3cbcfcd2.chunk.js","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/* eslint-disable no-await-in-loop,no-restricted-syntax */\n\nimport stringHash from 'string-hash';\n\nimport { Match } from './Match';\nimport { Token } from './Token';\n\nexport class Highlighter {\n  matches: Match[] = [];\n\n  constructor(\n    readonly getTextNodes: () => Node[],\n    readonly match: (paragraphs: string[]) => Promise<Token[][]>,\n    readonly minBatchTextLength: number = 1000\n  ) {}\n\n  /**\n   * Split given nodes into two groups:\n   * - Unchanged: the nodes whose value unchanged since last scan.\n   * - Changed and new: the newly found and changed nodes.\n   * @param nodes The nodes to group.\n   */\n  private groupNodes(nodes: Node[]) {\n    const oldMatchMap = new Map<number, Match>();\n    this.matches.forEach(it => {\n      oldMatchMap.set(it.nodeValueHash, it);\n    });\n\n    const unchanged: Match[] = [];\n    const changedAndNew: Match[] = [];\n    nodes.forEach(node => {\n      const nodeValue = node.nodeValue || '';\n      const nodeValueHash = stringHash(nodeValue);\n      const oldMatch = oldMatchMap.get(nodeValueHash);\n      const match: Match = {\n        node,\n        nodeValueHash,\n        tokens: oldMatch ? oldMatch.tokens : [],\n        ranges: [],\n      };\n      if (oldMatch) {\n        unchanged.push(match);\n      } else {\n        changedAndNew.push(match);\n      }\n    });\n\n    return { unchanged, changedAndNew };\n  }\n\n  /**\n   * Perform `match` for every item and set `item.tokens`.\n   * @param items The items to update tokens.\n   */\n  async setTokens(items: Match[]) {\n    const l = items.length;\n    let batch: Match[] = [];\n    let batchTextLength = 0;\n    for (let i = 0; i < l; i += 1) {\n      const match = items[i];\n      batch.push(match);\n      batchTextLength += (match.node.nodeValue || '').length;\n      if (i === l - 1 || batchTextLength > this.minBatchTextLength) {\n        const tokenGroups = await this.match(\n          batch.map(n => n.node.nodeValue || '')\n        );\n        for (let j = 0; j < batch.length; j += 1) {\n          batch[j].tokens = tokenGroups[j];\n        }\n        batch = [];\n        batchTextLength = 0;\n      }\n    }\n  }\n\n  async scan() {\n    this.matches.forEach(m => m.ranges.forEach(r => r.detach()));\n\n    const nodes = await this.getTextNodes();\n    const { unchanged, changedAndNew } = this.groupNodes(nodes);\n\n    // eslint-disable-next-line no-console\n    console.log(\n      `Highlighter.scan: unchanged=${unchanged.length}, changed and new: ${changedAndNew.length}`\n    );\n\n    await this.setTokens(changedAndNew);\n    this.matches = [...unchanged, ...changedAndNew];\n  }\n\n  updateHighlights() {\n    const makeRange = (m: Match, t: Token) => {\n      const r = document.createRange();\n      r.setStart(m.node, t.start);\n      r.setEnd(m.node, t.end);\n      return r;\n    };\n\n    for (const m of this.matches) {\n      m.ranges.forEach(r => r.detach());\n      m.ranges = m.tokens.map(t => makeRange(m, t));\n    }\n  }\n}\n","import React from 'react';\n\nimport { Token } from './Token';\n\nexport const Highlight = ({\n  token,\n  rect,\n  onMouseEnter,\n  onMouseLeave,\n}: {\n  token: Token;\n  rect: DOMRect;\n  onMouseEnter: (token: Token, rect: DOMRect, event: Event) => void;\n  onMouseLeave: (token: Token, rect: DOMRect, event: Event) => void;\n}) => (\n  <div\n    onMouseEnter={(event: any) => onMouseEnter(token, rect, event)}\n    onMouseLeave={(event: any) => onMouseLeave(token, rect, event)}\n    style={{\n      position: 'fixed',\n      top: rect.top,\n      left: rect.left,\n      width: rect.width,\n      height: rect.height - 1,\n      borderBottom: `2px solid ${token.color}`,\n      zIndex: 2147483647,\n    }}\n  />\n);\n","import throttle from 'lodash/throttle';\nimport React, { useEffect, useState } from 'react';\n\nimport { Highlight } from './Highlight';\nimport { Highlighter } from './Highlighter';\nimport { Token } from './Token';\n\n/**\n * `Highlights` properties.\n */\ninterface HighlightsProps {\n  /**\n   * The Highlighter instance.\n   */\n  highlighter: Highlighter;\n\n  /**\n   * Throttle updates, update at most once every specified milliseconds.\n   */\n  throttleUpdates: number;\n\n  onMouseEnterItem: (token: Token, rect: DOMRect, event: Event) => void;\n  onMouseLeaveItem: (token: Token, rect: DOMRect, event: Event) => void;\n}\n\nconst SCROLL = 'scroll' as const;\nconst RESIZE = 'resize' as const;\nlet UPDATE_HANDLER: any = null;\nlet mutationObserver: MutationObserver | null = null;\n\nconst deleteEventListeners = () => {\n  if (UPDATE_HANDLER) {\n    document.removeEventListener(SCROLL, UPDATE_HANDLER);\n    window.removeEventListener(RESIZE, UPDATE_HANDLER);\n    UPDATE_HANDLER = null;\n  }\n};\n\nexport const Highlights = ({\n  highlighter,\n  throttleUpdates,\n  onMouseEnterItem,\n  onMouseLeaveItem,\n}: HighlightsProps) => {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    deleteEventListeners();\n\n    const updateHighlights = (e: any) => {\n      console.log(\n        `Re-scan triggered by ${typeof e === 'object' && e.type ? e.type : e}`\n      );\n      highlighter.scan().then(() => setCount(v => v + 1));\n    };\n    const uu = throttle(updateHighlights, throttleUpdates);\n\n    UPDATE_HANDLER = uu;\n\n    mutationObserver = new MutationObserver((...args: any[]) => {\n      console.log(`DOM change:`, args);\n      uu('MutationObserver');\n    });\n    mutationObserver.observe(document.documentElement, {\n      attributes: false,\n      childList: true,\n      subtree: true,\n    });\n\n    updateHighlights('page load');\n    document.addEventListener('scroll', uu);\n    window.addEventListener('resize', uu);\n  }, [highlighter, throttleUpdates, setCount]);\n\n  // eslint-disable-next-line no-console\n  console.log(`Rendering highlights...#${count}`);\n\n  highlighter.updateHighlights();\n  return (\n    <>\n      {highlighter.matches\n        .map((m, mi) =>\n          m.ranges.filter(Boolean).map((r, ri) => {\n            const token = m.tokens[ri];\n            return Array.from(r.getClientRects()).map((rect, ri) => (\n              <Highlight\n                key={[mi, token.id, ri].join('-')}\n                token={token}\n                rect={rect}\n                onMouseEnter={onMouseEnterItem}\n                onMouseLeave={onMouseLeaveItem}\n              />\n            ));\n          })\n        )\n        .flat(3)}\n    </>\n  );\n};\n","/**\n * Tells whether the given DOMRect intersects with the viewport.\n * @param param0 The DOMRect to test.\n * @returns Returns `true` if any pixel in the DOMRect is visible on the screen,\n * even it is under the scrollbars; otherwise `false`;\n */\nexport const isRectPartiallyVisible = ({\n  left,\n  right,\n  top,\n  bottom,\n}: DOMRect) => {\n  const vw = window.innerWidth || document.documentElement.clientWidth;\n  const vh = window.innerHeight || document.documentElement.clientHeight;\n\n  return (\n    (top >= 0 && top <= vh && left >= 0 && left <= vw) || // top left\n    (bottom >= 0 && bottom <= vh && left >= 0 && left <= vw) || // bottom left\n    (top >= 0 && top <= vh && right >= 0 && right <= vw) || // top right\n    (bottom >= 0 && bottom <= vh && right >= 0 && right <= vw) // bottom right\n  );\n};\n","// eslint-disable-next-line no-control-regex\nconst REGEX_LEADING_TRAILING_CONTROL_CHARS = /^[\\u0000-\\u001F\\u21B5\\s]+|[\\u0000-\\u001F\\u21B5\\s]+$/gm;\n\n/**\n * Trim both leading and trailing control characters from every line.\n * @remarks\n *  New line characters (`\\r` and `\\n`) are left untouched.\n * @param s The string to trim.\n * @returns A new string with both leading and trailing control characters deleted from every line.\n */\nexport const trimInvisibleChars = (s: string) =>\n  s.replace(REGEX_LEADING_TRAILING_CONTROL_CHARS, '');\n","/* eslint-disable no-continue */\n\nimport { isElementVisible } from './isElementVisible';\nimport { isRectPartiallyVisible } from './isRectPartiallyVisible';\nimport { trimInvisibleChars as trim } from './trimInvisibleChars';\n\nconst findAllTextNodes = (\n  root: Node,\n  ignoreInvisibleNodes: boolean,\n  trimInvisibleChars: boolean,\n  minTextLength: number\n) => {\n  const walker = document.createTreeWalker(\n    root,\n    NodeFilter.SHOW_TEXT,\n    null,\n    false\n  );\n  const nodes = [];\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    const text = node.nodeValue || '';\n    if (minTextLength > 0) {\n      const s = trimInvisibleChars ? trim(text) : text;\n      if (s.length < minTextLength) {\n        continue;\n      }\n    }\n\n    if (ignoreInvisibleNodes) {\n      const { parentElement } = node;\n      if (!parentElement || !isElementVisible(parentElement)) {\n        continue;\n      }\n\n      if (!isRectPartiallyVisible(parentElement.getBoundingClientRect())) {\n        continue;\n      }\n    }\n\n    nodes.push(node);\n  }\n\n  return nodes;\n};\n\n/**\n * Gets all text nodes on the page.\n * @param selectors A string containing one or more selectors to match against.\n * This string must be a valid CSS selector string; if it's not, a SyntaxError\n * exception is thrown. Multiple selectors may be specified by separating\n * them using commas.\n * @param ignoreInvisibleNodes Exclude invisible text nodes.\n * @param trimInvisibleChars Whether to delete both leading and\n * trailing invisible characters before counting node text length.\n * @param minTextLength Exclude text nodes whose text length is less than give value.\n * @returns An array of text nodes that satisfy given conditions.\n */\nexport const getTextNodes = (\n  selectors = '',\n  ignoreInvisibleNodes = true,\n  trimInvisibleChars = true,\n  minTextLength = 3\n) => {\n  const docE = document.documentElement;\n  const roots = selectors\n    ? Array.from(docE.querySelectorAll(selectors))\n    : [docE];\n\n  return roots\n    .map(root =>\n      findAllTextNodes(\n        root,\n        ignoreInvisibleNodes,\n        trimInvisibleChars,\n        minTextLength\n      )\n    )\n    .flat(2);\n};\n","/**\n * Tells whether an HTMLElement is visible.\n * @remarks\n * - An HTMLElement is visible doesn't mean people can see it on the screen.\n * - The implementation is based on `jQuery`'s `:visible` selector. See\n *   https://github.com/jquery/jquery/blob/d0ce00cdfa680f1f0c38460bc51ea14079ae8b07/src/css/hiddenVisibleSelectors.js\n * - Alternatively, if not considering `position: fixed`, use `e.offsetParent !== null`. See\n *   https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n * @param e The HTMLElement to test.\n * @returns Returns `true` if the HTMLElement is visible as defined by the CSS rules;\n * otherwise `false`.\n */\nexport const isElementVisible = (e: HTMLElement) =>\n  !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);\n","import React from 'react';\n\nimport { Card } from './Card';\n\nexport const TokenView = ({ data }: { data: Card | null }) => {\n  if (!data) {\n    return null;\n  }\n\n  return (\n    <div\n      className=\"token-view\"\n      style={{\n        background: data.token.color,\n        top: data.rect.bottom,\n        left: data.rect.left,\n      }}\n    >\n      <ul>\n        <li>Card ID: {data.token.id}</li>\n        <li>Title: {data.token.keyword}</li>\n      </ul>\n    </div>\n  );\n};\n","import './index.css';\n\nimport { start, Token } from 'dom-highlight-lib';\nimport React, { useEffect, useState } from 'react';\nimport { render } from 'react-dom';\n\nimport { Card } from './Card';\nimport { TokenView } from './TokenView';\n\nconst radomColor = () => {\n  const colors = ['red', 'pink', 'orange', 'purple', 'blue', 'black', 'green'];\n  const int = Math.floor(Math.random() * 1000) % colors.length;\n  return colors[int];\n};\n\nlet id = 0;\n\nconst getRegExp = () => {\n  const str = localStorage.getItem('yali-dh-regex');\n  if (str) {\n    return new RegExp(str, 'mg');\n  }\n\n  return /\\w+/gm;\n};\n\nconst match = (paragraphs: string[]) => {\n  const regex = getRegExp();\n  return new Promise<Token[][]>(function(resolve, reject) {\n    const tokenize = (text: string) => {\n      const tokens: Token[] = [];\n      let m = regex.exec(text);\n      while (m !== null) {\n        tokens.push({\n          id: id.toString(),\n          color: radomColor(),\n          start: m.index,\n          end: m.index + m[0].length,\n          keyword: m[0],\n        });\n        id += 1;\n        m = regex.exec(text);\n      }\n      return tokens;\n    };\n\n    setTimeout(() => {\n      try {\n        const result = paragraphs.map(tokenize);\n        resolve(result);\n      } catch (e) {\n        reject(e);\n      }\n    }, 5);\n  });\n};\n\nconst App = () => {\n  const [data, setData] = useState<Card | null>(null);\n\n  useEffect(() => {\n    const showToken = (token: Token, rect: DOMRect) => {\n      setData({ token, rect });\n    };\n    const hideToken = () => setData(null);\n    start({\n      match,\n      showToken,\n      hideToken,\n      className: 'dh-underline',\n    });\n  }, [setData]);\n\n  const handleNewDOMNode = () => {\n    const div = document.createElement('div');\n    div.innerHTML = 'New DIV element';\n    document.body.appendChild(div);\n  };\n\n  return (\n    <React.Fragment>\n      <button onClick={handleNewDOMNode} style={{ padding: '5px 1em' }}>\n        Add New DOM Node, trigger mutation observer\n      </button>\n      <TokenView data={data} />\n    </React.Fragment>\n  );\n};\n\n// const isEnabled = localStorage.getItem('yali-dh-enabled');\n// if (isEnabled === 'true') {\nconst root = document.createElement('div');\nroot.style.margin = 'margin: 1em auto';\ndocument.body.appendChild(root);\nrender(<App />, root);\n// } else {\n//   console.log('Highlighter is disabled.');\n// }\n","import React from 'react';\nimport { render } from 'react-dom';\n\nimport { Highlighter } from './Highlighter';\nimport { Highlights } from './Highlights';\nimport { Token } from './Token';\nimport { getTextNodes } from './utils';\n\ninterface Options {\n  /**\n   * The asynchronous function that find tokens\n   * in give paragraphs.\n   */\n  match: (paragraphs: string[]) => Promise<Token[][]>;\n\n  /**\n   * Defines what to do when the user mouse hover on a token.\n   * @param token The token.\n   * @param rect The `DOMRect` where the user hovered on.\n   * Note that a token might have more than one `DOMRect`s.\n   * @param event The mouse event.\n   */\n  showToken: (token: Token, rect: DOMRect, event: Event) => void;\n\n  /**\n   * Defines what to do when the user moves mouse out of a token.\n   * @param token The token.\n   * @param rect The `DOMRect` where the user moved mouse out from.\n   * Note that a token might have more than one `DOMRect`s.\n   * @param event The mouse event.\n   */\n  hideToken: (token: Token, rect: DOMRect, event: Event) => void;\n\n  /**\n   * Specify CSS selector string of the root nodes to match.\n   * This string must be a valid CSS selector string; if it's not, a SyntaxError\n   * exception is thrown. Multiple selectors may be specified by separating\n   * them using commas.\n   *\n   * Defaults to the `document.documentElement`.\n   */\n  selectors?: string;\n\n  /**\n   * Whether ignores invisible nodes. Defaults to `true`.\n   * @remarks\n   * An HTML element is visible if both of below assertions are true:\n   * - The element is visible as defined by the CSS rules - it must\n   * has an `offsetParent`.\n   * - The element has intersection with the viewport - it is on the screen.\n   */\n  ignoreInvisibleNodes?: boolean;\n\n  /**\n   * Ignore text nodes whose text length is less than specified value.\n   * Defaults to `3`.\n   * @remarks\n   */\n  minTextLength?: number;\n\n  /**\n   * Whether ignores the leading and trailing invisible chars before\n   * counting the text length. Defaults to `true`.\n   */\n  trimInvisibleChars?: boolean;\n\n  /**\n   * Controls how often to invoke the\n   * `match` function according to the total number of characters\n   * in the paragraphs. Defaults to`1000`.\n   */\n  minBatchTextLength?: number;\n\n  /**\n   * The CSS class name for the highlights container.\n   * Defaults to empty string.\n   */\n  className?: string;\n\n  /**\n   * Throttle updates, update at most once every specified milliseconds.\n   * Defaults to `500`.\n   */\n  throttleUpdates?: number;\n}\n\n/**\n * Start highlighter.\n *\n * @param selectors\n * @param minBatchTextLength\n * @param className The CSS class name for the highlights container.\n * @param throttleUpdates  Throttle updates,\n * update at most once every specified milliseconds.\n */\nexport const start = ({\n  match,\n  showToken,\n  hideToken,\n  selectors = '',\n  ignoreInvisibleNodes = true,\n  minTextLength = 3,\n  trimInvisibleChars = true,\n  minBatchTextLength = 1000,\n  className = '',\n  throttleUpdates = 500,\n}: Options) => {\n  const findTextNodes = () =>\n    getTextNodes(\n      selectors,\n      ignoreInvisibleNodes,\n      trimInvisibleChars,\n      minTextLength\n    );\n  const highlighter = new Highlighter(findTextNodes, match, minBatchTextLength);\n\n  const highlights = document.createElement('highlights');\n  if (className) {\n    highlights.setAttribute('class', className);\n  }\n  document.body.appendChild(highlights);\n\n  render(\n    <Highlights\n      highlighter={highlighter}\n      throttleUpdates={throttleUpdates}\n      onMouseEnterItem={showToken}\n      onMouseLeaveItem={hideToken}\n    />,\n    highlights\n  );\n};\n"],"sourceRoot":""}