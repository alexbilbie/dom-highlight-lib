{"version":3,"sources":["../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/Highlighter.ts","../../src/Highlight.tsx","../../src/Highlights.tsx","../../src/utils/isRectPartiallyVisible.ts","../../src/utils/trimInvisibleChars.ts","../../src/utils/getTextNodes.ts","../../src/utils/isElementVisible.ts","TokenView.tsx","index.tsx","../../src/start.tsx"],"names":["_Pact","result","state","this","callback","_settle","e","value","_this","onFulfilled","onRejected","pact","observer","_isSettledPact","thenable","Symbol","Highlighter","minBatchTextLength","getTextNodes","match","matches","groupNodes","oldMatchMap","it","unchanged","changedAndNew","nodes","node","nodeValue","nodeValueHash","stringHash","oldMatch","tokens","ranges","l","items","batch","batchTextLength","i","test","update","body","shouldContinue","stage","updateValue","reject","_resumeAfterBody","_resumeAfterTest","n","m","tokenGroups","r","console","updateHighlights","a","document","Highlight","token","rect","onMouseEnter","onMouseLeave","style","position","top","left","width","height","borderBottom","color","UPDATE_HANDLER","Highlights","props","useState","count","setCount","useEffect","window","v","uu","throttle","MutationObserver","mutationObserver","attributes","childList","subtree","React","Array","key","mi","onMouseEnterItem","onMouseLeaveItem","isRectPartiallyVisible","right","bottom","vw","vh","REGEX_LEADING_TRAILING_CONTROL_CHARS","trimInvisibleChars","s","visibleOnly","minLength","walker","NodeFilter","text","trim","parentElement","TokenView","data","className","background","id","keyword","radomColor","colors","Math","floor","random","length","regex","paragraphs","Promise","resolve","tokenize","exec","push","toString","start","index","end","setTimeout","map","App","setData","throttleUpdates","highlighter","highlights","render","showToken","hideToken","Fragment","onClick","div","createElement","innerHTML","appendChild","padding","getElementById"],"mappings":"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","file":"static/js/main.785202fe.chunk.js","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import stringHash from 'string-hash';\n\nimport { Match } from './Match';\nimport { Token } from './Token';\n\nexport class Highlighter {\n  matches: Match[] = [];\n\n  constructor(\n    readonly getTextNodes: () => Node[],\n    readonly match: (paragraphs: string[]) => Promise<Token[][]>,\n    readonly minBatchTextLength: number = 1000\n  ) {}\n\n  /**\n   * Split given nodes into two groups:\n   * - Unchanged: the nodes whose value unchanged since last scan.\n   * - Changed and new: the newly found and changed nodes.\n   * @param nodes The nodes to group.\n   */\n  private groupNodes(nodes: Node[]) {\n    const oldMatchMap = new Map<number, Match>();\n    this.matches.forEach(it => {\n      oldMatchMap.set(it.nodeValueHash, it);\n    });\n\n    const unchanged: Match[] = [];\n    const changedAndNew: Match[] = [];\n    nodes.forEach(node => {\n      const nodeValue = node.nodeValue || '';\n      const nodeValueHash = stringHash(nodeValue);\n      const oldMatch = oldMatchMap.get(nodeValueHash);\n      const match: Match = {\n        node,\n        nodeValueHash,\n        tokens: oldMatch ? oldMatch.tokens : [],\n        ranges: [],\n      };\n      if (oldMatch) {\n        unchanged.push(match);\n      } else {\n        changedAndNew.push(match);\n      }\n    });\n\n    return { unchanged, changedAndNew };\n  }\n\n  /**\n   * Perform `match` for every item and set `item.tokens`.\n   * @param items The items to update tokens.\n   */\n  async setTokens(items: Match[]) {\n    const l = items.length;\n    let batch: Match[] = [];\n    let batchTextLength = 0;\n    for (let i = 0; i < l; i += 1) {\n      const match = items[i];\n      batch.push(match);\n      batchTextLength += (match.node.nodeValue || '').length;\n      if (i === l - 1 || batchTextLength > this.minBatchTextLength) {\n        const tokenGroups = await this.match(\n          batch.map(n => n.node.nodeValue || '')\n        );\n        batch.forEach((m, i) => {\n          m.tokens = tokenGroups[i];\n        });\n\n        batch = [];\n        batchTextLength = 0;\n      }\n    }\n  }\n\n  async scan() {\n    this.matches.forEach(m => m.ranges.forEach(r => r.detach()));\n\n    const nodes = await this.getTextNodes();\n    const { unchanged, changedAndNew } = this.groupNodes(nodes);\n\n    console.log(\n      `Highlighter.scan: unchanged=${unchanged.length}, changed and new: ${changedAndNew.length}`\n    );\n\n    await this.setTokens(changedAndNew);\n    this.matches = [...unchanged, ...changedAndNew];\n  }\n\n  updateHighlights() {\n    for (const m of this.matches) {\n      m.ranges.forEach(r => r.detach());\n\n      m.ranges = m.tokens.map(a => {\n        const r = document.createRange();\n        r.setStart(m.node, a.start);\n        r.setEnd(m.node, a.end);\n        return r;\n      });\n    }\n  }\n}\n","import React from 'react';\n\nimport { Token } from './Token';\n\nexport const Highlight = ({\n  token,\n  rect,\n  onMouseEnter,\n  onMouseLeave,\n}: {\n  token: Token;\n  rect: DOMRect;\n  onMouseEnter: (token: Token, rect: DOMRect, event: Event) => void;\n  onMouseLeave: (token: Token, rect: DOMRect, event: Event) => void;\n}) => (\n  <div\n    onMouseEnter={(event: any) => onMouseEnter(token, rect, event)}\n    onMouseLeave={(event: any) => onMouseLeave(token, rect, event)}\n    style={{\n      position: 'fixed',\n      top: rect.top,\n      left: rect.left,\n      width: rect.width,\n      height: rect.height - 2,\n      borderBottom: `2px solid ${token.color}`,\n    }}\n  />\n);\n","import throttle from 'lodash/throttle';\nimport React, { useEffect, useState } from 'react';\n\nimport { Highlight } from './Highlight';\nimport { Highlighter } from './Highlighter';\nimport { Token } from './Token';\n\n/**\n * `Highlights` properties.\n */\ninterface HighlightsProps {\n  /**\n   * The Highlighter instance.\n   */\n  highlighter: Highlighter;\n\n  /**\n   * Throttle updates, update at most once every specified milliseconds.\n   */\n  throttleUpdates: number;\n\n  /**\n   * The CSS class name for the highlights container.\n   */\n  className: string;\n\n  onMouseEnterItem: (token: Token, rect: DOMRect, event: Event) => void;\n  onMouseLeaveItem: (token: Token, rect: DOMRect, event: Event) => void;\n}\n\nconst SCROLL = 'scroll' as const;\nconst RESIZE = 'resize' as const;\nlet UPDATE_HANDLER: any = null;\nlet mutationObserver: MutationObserver | null = null;\n\nconst deleteEventListeners = () => {\n  if (UPDATE_HANDLER) {\n    document.removeEventListener(SCROLL, UPDATE_HANDLER);\n    window.removeEventListener(RESIZE, UPDATE_HANDLER);\n    UPDATE_HANDLER = null;\n  }\n};\n\nexport const Highlights = (props: HighlightsProps) => {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    deleteEventListeners();\n\n    const update = () =>\n      props.highlighter.scan().then(() => setCount(v => v + 1));\n    const uu = throttle(update, props.throttleUpdates);\n    UPDATE_HANDLER = uu;\n\n    mutationObserver = new MutationObserver(uu);\n    mutationObserver.observe(document.documentElement, {\n      attributes: true,\n      childList: true,\n      subtree: true,\n    });\n\n    update();\n    document.addEventListener('scroll', uu);\n    window.addEventListener('resize', uu);\n  }, [props.highlighter, props.throttleUpdates, setCount]);\n\n  console.log(`Rendering highlights...#${count}`);\n\n  props.highlighter.updateHighlights();\n  return (\n    <React.Fragment>\n      {props.highlighter.matches\n        .map((m, mi) =>\n          m.ranges.filter(Boolean).map((r, ri) => {\n            const token = m.tokens[ri];\n            return Array.from(r.getClientRects()).map((rect, ri) => (\n              <Highlight\n                key={[mi, token.id, ri].join('-')}\n                token={token}\n                rect={rect}\n                onMouseEnter={props.onMouseEnterItem}\n                onMouseLeave={props.onMouseLeaveItem}\n              />\n            ));\n          })\n        )\n        .flat(3)}\n    </React.Fragment>\n  );\n};\n","/**\n * Tells whether the given DOMRect intersects with the viewport.\n * @param param0 The DOMRect to test.\n * @returns Returns `true` if any pixel in the DOMRect is visible on the screen,\n * even it is under the scrollbars; otherwise `false`;\n */\nexport const isRectPartiallyVisible = ({\n  left,\n  right,\n  top,\n  bottom,\n}: DOMRect) => {\n  const vw = window.innerWidth || document.documentElement.clientWidth;\n  const vh = window.innerHeight || document.documentElement.clientHeight;\n\n  return (\n    (top >= 0 && top <= vh && left >= 0 && left <= vw) || // top left\n    (bottom >= 0 && bottom <= vh && left >= 0 && left <= vw) || // bottom left\n    (top >= 0 && top <= vh && right >= 0 && right <= vw) || // top right\n    (bottom >= 0 && bottom <= vh && right >= 0 && right <= vw) // bottom right\n  );\n};\n","// eslint-disable-next-line no-control-regex\nconst REGEX_LEADING_TRAILING_CONTROL_CHARS = /^[\\u0000-\\u001F\\u21B5\\s]+|[\\u0000-\\u001F\\u21B5\\s]+$/gm;\n\n/**\n * Trim both leading and trailing control characters from every line.\n * @remarks\n *  New line characters (`\\r` and `\\n`) are left untouched.\n * @param s The string to trim.\n * @returns A new string with both leading and trailing control characters deleted from every line.\n */\nexport const trimInvisibleChars = (s: string) =>\n  s.replace(REGEX_LEADING_TRAILING_CONTROL_CHARS, '');\n","import { isElementVisible } from './isElementVisible';\nimport { isRectPartiallyVisible } from './isRectPartiallyVisible';\nimport { trimInvisibleChars as trim } from './trimInvisibleChars';\n\n/**\n * Gets all text nodes on the page.\n * @param visibleOnly Exclude invisible text nodes.\n * @param trimInvisibleChars Whether to delete both leading and\n * trailing invisible characters before counting node text length.\n * @param minLength Exclude text nodes whose text length is less than give value.\n * @returns An array of text nodes that satisfy given conditions.\n */\nexport const getTextNodes = (\n  visibleOnly = true,\n  trimInvisibleChars = true,\n  minLength = 3\n) => {\n  const walker = document.createTreeWalker(\n    document.documentElement,\n    NodeFilter.SHOW_TEXT,\n    null,\n    false\n  );\n  const nodes = [];\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    const text = node.nodeValue || '';\n    if (minLength > 0) {\n      const s = trimInvisibleChars ? trim(text) : text;\n      if (s.length < minLength) {\n        continue;\n      }\n    }\n\n    if (visibleOnly) {\n      const { parentElement } = node;\n      if (!parentElement || !isElementVisible(parentElement)) {\n        continue;\n      }\n\n      if (!isRectPartiallyVisible(parentElement.getBoundingClientRect())) {\n        continue;\n      }\n    }\n\n    nodes.push(node);\n  }\n\n  return nodes;\n};\n","/**\n * Tells whether an HTMLElement is visible.\n * @remarks\n * - An HTMLElement is visible doesn't mean people can see it on the screen.\n * - The implementation is based on `jQuery`'s `:visible` selector. See\n *   https://github.com/jquery/jquery/blob/d0ce00cdfa680f1f0c38460bc51ea14079ae8b07/src/css/hiddenVisibleSelectors.js\n * - Alternatively, if not considering `position: fixed`, use `e.offsetParent !== null`. See\n *   https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n * @param e The HTMLElement to test.\n * @returns Returns `true` if the HTMLElement is visible as defined by the CSS rules;\n * otherwise `false`.\n */\nexport const isElementVisible = (e: HTMLElement) =>\n  !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);\n","import React from 'react';\n\nimport { Card } from './Card';\n\nexport const TokenView = ({ data }: { data: Card | null }) => {\n  if (!data) {\n    return null;\n  }\n\n  return (\n    <div\n      className=\"token-view\"\n      style={{\n        background: data.token.color,\n        top: data.rect.bottom,\n        left: data.rect.left,\n      }}\n    >\n      <ul>\n        <li>Card ID: {data.token.id}</li>\n        <li>Title: {data.token.keyword}</li>\n      </ul>\n    </div>\n  );\n};\n","import './index.css';\n\nimport { start, Token } from 'dom-highlight-lib';\nimport React, { useEffect, useState } from 'react';\nimport { render } from 'react-dom';\n\nimport { Card } from './Card';\nimport { TokenView } from './TokenView';\n\nconst radomColor = () => {\n  const colors = ['red', 'pink', 'orange', 'purple', 'blue', 'black', 'green'];\n  const int = Math.floor(Math.random() * 1000) % colors.length;\n  return colors[int];\n};\n\nlet id = 0;\nconst regex = /\\w+/gm;\nconst match = (paragraphs: string[]) =>\n  new Promise<Token[][]>(function(resolve, reject) {\n    const tokenize = (text: string) => {\n      const tokens: Token[] = [];\n      let m = regex.exec(text);\n      while (m !== null) {\n        tokens.push({\n          id: id.toString(),\n          color: radomColor(),\n          start: m.index,\n          end: m.index + m[0].length,\n          keyword: m[0],\n        });\n        id += 1;\n        m = regex.exec(text);\n      }\n      return tokens;\n    };\n\n    setTimeout(() => {\n      try {\n        const result = paragraphs.map(tokenize);\n        resolve(result);\n      } catch (e) {\n        reject(e);\n      }\n    }, 5);\n  });\n\nconst App = () => {\n  const [data, setData] = useState<Card | null>(null);\n\n  useEffect(() => {\n    const showToken = (token: Token, rect: DOMRect) => {\n      setData({ token, rect });\n    };\n    const hideToken = () => setData(null);\n    start(match, showToken, hideToken, 20, 'dh-underline', 500);\n  }, [setData]);\n\n  const handleNewDOMNode = () => {\n    const div = document.createElement('div');\n    div.innerHTML = 'New DIV element';\n    document.body.appendChild(div);\n  };\n\n  return (\n    <React.Fragment>\n      <button onClick={handleNewDOMNode} style={{ padding: '5px 1em' }}>\n        Add New DOM Node, trigger mutation observer\n      </button>\n      <TokenView data={data} />\n    </React.Fragment>\n  );\n};\n\nrender(<App />, document.getElementById('root'));\n","import React from 'react';\nimport { render } from 'react-dom';\n\nimport { Highlighter } from './Highlighter';\nimport { Highlights } from './Highlights';\nimport { Token } from './Token';\nimport { getTextNodes } from './utils';\n\n/**\n * Start highlighter.\n *\n * @param match The asynchronous function that find tokens\n * in give paragraphs.\n * @param minBatchTextLength Controls how often to invoke the\n * `match` function according to the total number of characters\n * in the paragraphs.\n * @param className The CSS class name for the highlights container.\n * @param throttleUpdates  Throttle updates,\n * update at most once every specified milliseconds.\n */\nexport const start = (\n  match: (paragraphs: string[]) => Promise<Token[][]>,\n  showToken: (token: Token, rect: DOMRect, event: Event) => void,\n  hideToken: (token: Token, rect: DOMRect, event: Event) => void,\n  minBatchTextLength: number = 1000,\n  className: string = '',\n  throttleUpdates: number = 500\n) => {\n  const highlighter = new Highlighter(getTextNodes, match, minBatchTextLength);\n\n  const highlights = document.createElement('highlights');\n  highlights.setAttribute('class', className);\n  document.body.appendChild(highlights);\n  render(\n    <Highlights\n      highlighter={highlighter}\n      throttleUpdates={throttleUpdates}\n      className={className}\n      onMouseEnterItem={showToken}\n      onMouseLeaveItem={hideToken}\n    />,\n    highlights\n  );\n};\n"],"sourceRoot":""}