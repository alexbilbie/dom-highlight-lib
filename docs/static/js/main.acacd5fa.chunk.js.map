{"version":3,"sources":["../../src/utils/trimInvisibleChars.ts","../../src/utils/getTextNodes.ts","../../src/utils/isElementVisible.ts","../../src/utils/isRectPartiallyVisible.ts","../../src/utils/isDescendant.ts","../../src/Highlighter.ts","../../src/Highlight.tsx","../../src/makeMutationObserver.ts","../../src/Highlights.tsx","TokenView.tsx","index.tsx","../../src/start.tsx"],"names":["REGEX_LEADING_TRAILING_CONTROL_CHARS","testTextNode","textNode","e","minTextLength","filters","trimInvisibleChars","ignoreInvisibleNodes","text","s","trim","parentElement","left","right","top","bottom","vw","window","document","vh","isRectPartiallyVisible","getDescendantTextNodes","walker","NodeFilter","textNodes","isDescendant","ancestor","parent","descendant","Highlighter","config","matches","detachRanges","this","m","n","r","nonEmptyMatches","tokenGroups","i","setNodes","oldMatches","newMatches","node","nodeValueHash","stringHash","nodeRef","ranges","oldMatch","newMatch","tokens","nodeRefs","match","forceUpdate","promises","Array","minBatchTextLength","batch","batchTextLength","setTokens","Promise","addNodes","numberOfNewNodes","rootNodes","root","it","console","removeNodes","numberOfRemovedNodes","removedMatchKeys","ref","key","updateNodes","scan","nodes","selectors","docE","getTextNodes","updateHighlights","t","makeRange","Highlight","token","rect","onMouseEnter","onMouseLeave","style","position","width","height","borderBottom","zIndex","makeMutationObserver","ignoreMutations","MutationObserver","ignoreNodes","records","target","removed","highlighter","sequence","changeRecords","addedNodes","error","UPDATE_HANDLER","mutationObserver","Highlights","throttleUpdates","onMouseEnterItem","onMouseLeaveItem","useState","count","setCount","useEffect","deleteEventListeners","flush","v","uu","throttle","attributes","childList","subtree","type","React","range","TokenView","data","className","background","color","id","keyword","radomColor","colors","Math","floor","random","length","paragraphs","regex","str","localStorage","getItem","RegExp","getRegExp","resolve","reject","tokenize","exec","push","toString","start","index","end","setTimeout","result","map","App","container","setData","highlights","options","render","showToken","hideToken","Fragment","onClick","div","createElement","innerHTML","body","appendChild","padding","margin"],"mappings":"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","file":"static/js/main.acacd5fa.chunk.js","sourcesContent":["// eslint-disable-next-line no-control-regex\nconst REGEX_LEADING_TRAILING_CONTROL_CHARS = /^[\\u0000-\\u001F\\u21B5\\s]+|[\\u0000-\\u001F\\u21B5\\s]+$/gm;\n\n/**\n * Trim both leading and trailing control characters from every line.\n * @remarks\n *  New line characters (`\\r` and `\\n`) are left untouched.\n * @param s The string to trim.\n * @returns A new string with both leading and trailing control characters deleted from every line.\n */\nexport const trimInvisibleChars = (s: string) =>\n  s.replace(REGEX_LEADING_TRAILING_CONTROL_CHARS, '');\n","import { isElementVisible } from './isElementVisible';\nimport { isRectPartiallyVisible } from './isRectPartiallyVisible';\nimport { trimInvisibleChars as trim } from './trimInvisibleChars';\n\n/**\n * Tells whether the specified text node satisfies the given filters.\n * @param textNode The text node to test.\n * @param filters The text node filters.\n * @returns `true` if the text node satisfies all of the give filters;\n * otherwise `false`.\n */\nexport const testTextNode = (textNode: Node, filters: TextNodeFilter) => {\n  const { minTextLength, trimInvisibleChars, ignoreInvisibleNodes } = filters;\n  const text = textNode.nodeValue || '';\n  if (minTextLength > 0) {\n    const s = trimInvisibleChars ? trim(text) : text;\n    if (s.length < minTextLength) {\n      return false;\n    }\n  }\n\n  if (ignoreInvisibleNodes) {\n    const { parentElement } = textNode;\n    if (!parentElement || !isElementVisible(parentElement)) {\n      return false;\n    }\n\n    if (!isRectPartiallyVisible(parentElement.getBoundingClientRect())) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Gets all text nodes in the specified root node.\n * @param filters The text node filters.\n * @returns An array of text nodes that satisfy given filters.\n */\nexport const getDescendantTextNodes = (filters: DescendantTextNodeFilter) => {\n  const walker = document.createTreeWalker(\n    filters.root,\n    NodeFilter.SHOW_TEXT,\n    null,\n    false,\n  );\n\n  const textNodes = [];\n  while (walker.nextNode()) {\n    if (testTextNode(walker.currentNode, filters)) {\n      textNodes.push(walker.currentNode);\n    }\n  }\n  return textNodes;\n};\n\n/**\n * Gets all text nodes on the page.\n * @param param0 The text node selector.\n * @returns An array of text nodes that satisfy given filters.\n */\nexport const getTextNodes = ({\n  selectors = '',\n  ignoreInvisibleNodes = true,\n  trimInvisibleChars = true,\n  minTextLength = 3,\n}: TextNodeSelector) => {\n  const docE = document.documentElement;\n  const roots = selectors\n    ? Array.from(docE.querySelectorAll(selectors))\n    : [docE];\n\n  return roots\n    .map(root =>\n      getDescendantTextNodes({\n        root,\n        ignoreInvisibleNodes,\n        trimInvisibleChars,\n        minTextLength,\n      }),\n    )\n    .flat(2);\n};\n","/**\n * Tells whether an HTMLElement is visible.\n * @remarks\n * - An HTMLElement is visible doesn't mean people can see it on the screen.\n * - The implementation is based on `jQuery`'s `:visible` selector. See\n *   https://github.com/jquery/jquery/blob/d0ce00cdfa680f1f0c38460bc51ea14079ae8b07/src/css/hiddenVisibleSelectors.js\n * - Alternatively, if not considering `position: fixed`, use `e.offsetParent !== null`. See\n *   https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n * @param e The HTMLElement to test.\n * @returns Returns `true` if the HTMLElement is visible as defined by the CSS rules;\n * otherwise `false`.\n */\nexport const isElementVisible = (e: HTMLElement) =>\n  !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);\n","/* eslint-disable complexity */\n\n/**\n * Tells whether the given DOMRect intersects with the viewport.\n * @param param0 The DOMRect to test.\n * @returns Returns `true` if any pixel in the DOMRect is visible on the screen,\n * even it is under the scrollbars; otherwise `false`;\n */\nexport const isRectPartiallyVisible = ({\n  left,\n  right,\n  top,\n  bottom,\n}: DOMRect) => {\n  const vw = window.innerWidth || document.documentElement.clientWidth;\n  const vh = window.innerHeight || document.documentElement.clientHeight;\n\n  if (top >= 0 && top <= vh) {\n    return (left >= 0 && left <= vw) // top left\n      || (right >= 0 && right <= vw); // top right\n  }\n\n  if (bottom >= 0 && bottom <= vh) {\n    return (left >= 0 && left <= vw) // bottom left\n    || (right >= 0 && right <= vw); // bottom right\n  }\n\n  return false\n};\n","/**\n * Tells whether the first node is an ancestor of the second.\n * @param ancestor The first node.\n * @param descendant The second node.\n * @returns `true` if the first node is an ancestor of the second;\n * otherwise `false`.\n */\nexport const isDescendant = (ancestor: Node, descendant: Node) => {\n  let parent = descendant.parentNode;\n  while (parent !== null) {\n    if (parent === ancestor) {\n      return true;\n    }\n    parent = parent.parentNode;\n  }\n\n  return false;\n};\n","/* eslint-disable no-await-in-loop,no-restricted-syntax,no-console */\nimport stringHash from 'string-hash';\n\nimport { HighlighterConfig } from './HighlighterConfig';\nimport {\n  Match,\n  NodeRef,\n} from './Match';\nimport { Token } from './Token';\nimport {\n  getDescendantTextNodes,\n  getTextNodes,\n  isDescendant,\n} from './utils';\n\nexport class Highlighter {\n  /**\n   * The current matches in a `Map`.\n   * - Key is the hash value of the node text content, different\n   * nodes with same text content share same key.\n   * - Value is an array of `Match` (different DOM nodes).\n   */\n  matches: Map<number, Match> = new Map();\n\n  constructor(readonly config: HighlighterConfig) {}\n\n  detachRanges() {\n    this.matches.forEach(m =>\n      m.nodeRefs.forEach(n => n.ranges.forEach(r => r.detach)),\n    );\n  }\n\n  async setTokens(matches: Match[]) {\n    const nonEmptyMatches: Match[] = [];\n    matches.forEach(m => {\n      if (m.nodeRefs.length) {\n        nonEmptyMatches.push(m);\n      } else {\n        m.tokens = [];\n      }\n    });\n\n    const tokenGroups = await this.config.match(\n      nonEmptyMatches.map(m => m.nodeRefs[0].node.nodeValue || ''),\n    );\n    for (let i = 0; i < nonEmptyMatches.length; i += 1) {\n      nonEmptyMatches[i].tokens = tokenGroups[i];\n    }\n  }\n\n  setNodes(textNodes: Node[]): Promise<void> {\n    this.detachRanges();\n    const oldMatches = this.matches;\n    const newMatches: Map<number, Match> = new Map();\n    textNodes.forEach(node => {\n      const nodeValueHash = stringHash(node.nodeValue || '');\n      const nodeRef: NodeRef = { node, ranges: [] };\n\n      const oldMatch = oldMatches.get(nodeValueHash);\n      const newMatch = newMatches.get(nodeValueHash);\n      if (newMatch) {\n        newMatch.nodeRefs.push(nodeRef);\n      } else {\n        newMatches.set(nodeValueHash, {\n          tokens: oldMatch?.tokens,\n          nodeRefs: [nodeRef],\n        });\n      }\n    });\n\n    this.matches = newMatches;\n    return this.match();\n  }\n\n  /**\n   * Find tokens for matches.\n   * @param forceUpdate If `false`, skip the matches that have tokens;\n   * otherwise ignore existing tokens.\n   */\n  match(forceUpdate: boolean = false): Promise<void> {\n    const promises: Promise<void>[] = [];\n    let matches = Array.from(this.matches.values());\n    if (!forceUpdate) {\n      matches = matches.filter(m => !m.tokens);\n    }\n\n    const { minBatchTextLength = 1000 } = this.config;\n    let batch: Match[] = [];\n    let batchTextLength = 0;\n    for (const match of matches) {\n      if (match.nodeRefs.length > 0) {\n        batch.push(match);\n        batchTextLength += (match.nodeRefs[0].node.nodeValue || '').length;\n        if (batchTextLength > minBatchTextLength) {\n          promises.push(this.setTokens(batch));\n          batch = [];\n          batchTextLength = 0;\n        }\n      }\n    }\n\n    if (batch.length > 0) {\n      promises.push(this.setTokens(batch));\n    }\n\n    return Promise.all(promises).then(() => {});\n  }\n\n  addNodes(rootNodes: Node[]): Promise<void> {\n    let numberOfNewNodes = 0;\n    rootNodes\n      .map(node => getDescendantTextNodes({ root: node, ...this.config }))\n      .flat(2)\n      .forEach(node => {\n        const nodeValueHash = stringHash(node.nodeValue || '');\n        const nodeRef: NodeRef = { node, ranges: [] };\n        const match = this.matches.get(nodeValueHash);\n        if (match) {\n          if (!match.nodeRefs.some(it => it.node === node)) {\n            match.nodeRefs.push(nodeRef);\n            numberOfNewNodes += 1;\n          }\n        } else {\n          this.matches.set(nodeValueHash, { nodeRefs: [nodeRef] });\n          numberOfNewNodes += 1;\n        }\n      });\n\n    console.log(`addNodes: found ${numberOfNewNodes} new text nodes`);\n    if (numberOfNewNodes > 0) {\n      return this.match();\n    }\n\n    return Promise.resolve();\n  }\n\n  removeNodes(rootNodes: Node[]) {\n    let numberOfRemovedNodes = 0;\n    const removedMatchKeys: number[] = [];\n    this.matches.forEach((match, key) => {\n      match.nodeRefs = match.nodeRefs.filter(ref => {\n        if (rootNodes.some(r => r === ref.node || isDescendant(r, ref.node))) {\n          numberOfRemovedNodes += 1;\n          ref.ranges.forEach(r => r.detach());\n          return false;\n        }\n\n        return true;\n      });\n\n      if (match.nodeRefs.length === 0) {\n        removedMatchKeys.push(key);\n      }\n    });\n\n    removedMatchKeys.forEach(key => {\n      this.matches.delete(key);\n    });\n\n    console.log(`removeNodes: removed ${numberOfRemovedNodes} text nodes`);\n  }\n\n  updateNodes(rootNodes: Node[]): Promise<void> {\n    this.removeNodes(rootNodes);\n    return this.addNodes(rootNodes);\n  }\n\n  scan(): Promise<void> {\n    const nodes = getTextNodes(this.config);\n    return this.setNodes(nodes);\n  }\n\n  updateHighlights() {\n    const makeRange = (ref: NodeRef, t: Token) => {\n      const r = document.createRange();\n      r.setStart(ref.node, t.start);\n      r.setEnd(ref.node, t.end);\n      return r;\n    };\n\n    this.matches.forEach(m =>\n      m.nodeRefs.forEach(ref => {\n        ref.ranges.forEach(r => r.detach());\n        ref.ranges = (m.tokens || []).map(t => makeRange(ref, t));\n      }),\n    );\n  }\n}\n","import React from 'react';\n\nimport { Token } from './Token';\n\nconst UNDERLINE_OFFSET_BOTTOM = 1 as const;\n\nexport const Highlight = ({\n  token,\n  rect,\n  onMouseEnter,\n  onMouseLeave,\n}: {\n  token: Token;\n  rect: DOMRect;\n  onMouseEnter: (token: Token, rect: DOMRect, event: Event) => void;\n  onMouseLeave: (token: Token, rect: DOMRect, event: Event) => void;\n}) => (\n  <div\n    onMouseEnter={(event: any) => onMouseEnter(token, rect, event)}\n    onMouseLeave={(event: any) => onMouseLeave(token, rect, event)}\n    style={{\n      position: 'fixed',\n      top: rect.top,\n      left: rect.left,\n      width: rect.width,\n      height: rect.height - UNDERLINE_OFFSET_BOTTOM,\n      borderBottom: `2px solid ${token.color}`,\n      zIndex: 2147483647,\n    }}\n  />\n);\n","import { Highlighter } from './Highlighter';\nimport { isDescendant } from './utils';\n\nconst getNodes = (selectorOrRefs: (string | Node)[]): Node[] =>\n  selectorOrRefs\n    .map(it => {\n      if (typeof it === 'string') {\n        return it ? Array.from(document.querySelectorAll(it)) : [];\n      }\n\n      return [it];\n    })\n    .flat(2);\n\nexport const makeMutationObserver = (\n  highlighter: Highlighter,\n  done: () => void,\n  ignoreMutations: (string | Node)[] = [],\n) =>\n  new MutationObserver((mutations: MutationRecord[]) => {\n    const ignoreNodes = getNodes(ignoreMutations);\n    let records = mutations;\n    if (ignoreNodes) {\n      records = records.filter(\n        ({ target }) =>\n          target &&\n          !ignoreNodes.some(it => it === target || isDescendant(it, target)),\n      );\n    }\n\n    if (records.length === 0) {\n      return;\n    }\n\n    const removed = records.map(it => Array.from(it.removedNodes)).flat(2);\n    if (removed.length > 0) {\n      highlighter.removeNodes(removed);\n    }\n\n    let sequence = Promise.resolve();\n    const changeRecords = records.filter(it => it.type === 'characterData');\n    if (changeRecords.length > 0) {\n      sequence = sequence.then(() =>\n        highlighter.updateNodes(changeRecords.map(it => it.target)),\n      );\n    }\n\n    const addedNodes = records.map(it => Array.from(it.addedNodes)).flat(2);\n    if (addedNodes.length > 0) {\n      sequence = sequence.then(() => highlighter.addNodes(addedNodes));\n    }\n\n    sequence.then(done).catch(error => {\n      console.error('Failed to process MutationRecords', records, error);\n    });\n  });\n","import throttle from 'lodash/throttle';\nimport React, {\n  useEffect,\n  useState,\n} from 'react';\n\nimport { Highlight } from './Highlight';\nimport { Highlighter } from './Highlighter';\nimport { makeMutationObserver } from './makeMutationObserver';\nimport { Token } from './Token';\n\n/**\n * `Highlights` properties.\n */\ninterface HighlightsProps {\n  /**\n   * The Highlighter instance.\n   */\n  highlighter: Highlighter;\n\n  /**\n   * Throttle updates, update at most once every specified milliseconds.\n   */\n  throttleUpdates: number;\n\n  /**\n   * A selector or an array of `Node` that do nothing when they mutate.\n   */\n  ignoreMutations: (string | Node)[];\n\n  onMouseEnterItem: (token: Token, rect: DOMRect, event: Event) => void;\n  onMouseLeaveItem: (token: Token, rect: DOMRect, event: Event) => void;\n}\n\nconst SCROLL = 'scroll' as const;\nconst RESIZE = 'resize' as const;\nlet UPDATE_HANDLER: any = null;\nlet mutationObserver: MutationObserver | null = null;\n\nconst deleteEventListeners = () => {\n  if (UPDATE_HANDLER) {\n    window.removeEventListener(SCROLL, UPDATE_HANDLER);\n    window.removeEventListener(RESIZE, UPDATE_HANDLER);\n    UPDATE_HANDLER = null;\n    mutationObserver?.disconnect();\n  }\n};\n\nexport const Highlights = ({\n  highlighter,\n  throttleUpdates,\n  ignoreMutations,\n  onMouseEnterItem,\n  onMouseLeaveItem,\n}: HighlightsProps) => {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    deleteEventListeners();\n    const flush = () => setCount(v => v + 1);\n\n    const scan = (e: { type: string }) => {\n      console.log(`Scan triggered by ${e.type}`);\n      highlighter.scan().then(flush);\n    };\n    const uu = throttle(scan, throttleUpdates);\n\n    window.addEventListener(SCROLL, uu);\n    window.addEventListener(RESIZE, uu);\n    UPDATE_HANDLER = uu;\n\n    if (!mutationObserver) {\n      mutationObserver = makeMutationObserver(\n        highlighter,\n        flush,\n        ignoreMutations,\n      );\n    }\n\n    mutationObserver?.observe(document.documentElement, {\n      attributes: false,\n      childList: true,\n      subtree: true,\n    });\n\n    scan({ type: 'page load' });\n  }, [\n    highlighter,\n    throttleUpdates,\n    setCount,\n    ignoreMutations,\n  ]);\n\n  // eslint-disable-next-line no-console\n  console.log(`Rendering highlights...#${count}`);\n\n  highlighter.updateHighlights();\n  return (\n    <>\n      {Array.from(highlighter.matches.values())\n        .map((match, matchIndex) =>\n          match.nodeRefs.map((ref, refIndex) =>\n            ref.ranges.filter(Boolean).map((range, rangeIndex) => {\n              const token = (match.tokens || [])[rangeIndex];\n              return Array.from(\n                range.getClientRects(),\n              ).map((rect, rectIndex) => (\n                <Highlight\n                  key={[\n                    matchIndex,\n                    refIndex,\n                    token.id,\n                    rangeIndex,\n                    rectIndex,\n                  ].join('-')}\n                  token={token}\n                  rect={rect}\n                  onMouseEnter={onMouseEnterItem}\n                  onMouseLeave={onMouseLeaveItem}\n                />\n              ));\n            }),\n          ),\n        )\n        .flat(4)}\n    </>\n  );\n};\n","import React from 'react';\n\nimport { Card } from './Card';\n\nexport const TokenView = ({ data }: { data: Card | null }) => {\n  if (!data) {\n    return null;\n  }\n\n  return (\n    <div\n      className=\"token-view\"\n      style={{\n        background: data.token.color,\n        top: data.rect.bottom,\n        left: data.rect.left,\n      }}\n    >\n      <ul>\n        <li>Card ID: {data.token.id}</li>\n        <li>Title: {data.token.keyword}</li>\n      </ul>\n    </div>\n  );\n};\n","import './index.css';\n\nimport {\n  start,\n  Token,\n} from 'dom-highlight-lib';\nimport React, {\n  useEffect,\n  useState,\n} from 'react';\nimport { render } from 'react-dom';\n\nimport { Card } from './Card';\nimport { TokenView } from './TokenView';\n\nconst radomColor = () => {\n  const colors = ['red', 'pink', 'orange', 'purple', 'blue', 'black', 'green'];\n  const int = Math.floor(Math.random() * 1000) % colors.length;\n  return colors[int];\n};\n\nlet id = 0;\n\nconst getRegExp = () => {\n  const str = localStorage.getItem('yali-dh-regex');\n  if (str) {\n    return new RegExp(str, 'mg');\n  }\n\n  return /\\w+/gm;\n};\n\nconst match = (paragraphs: string[]) => {\n  const regex = getRegExp();\n  return new Promise<Token[][]>(function(resolve, reject) {\n    const tokenize = (text: string) => {\n      const tokens: Token[] = [];\n      let m = regex.exec(text);\n      while (m !== null) {\n        tokens.push({\n          id: id.toString(),\n          color: radomColor(),\n          start: m.index,\n          end: m.index + m[0].length,\n          keyword: m[0],\n        });\n        id += 1;\n        m = regex.exec(text);\n      }\n      return tokens;\n    };\n\n    setTimeout(() => {\n      try {\n        const result = paragraphs.map(tokenize);\n        resolve(result);\n      } catch (e) {\n        reject(e);\n      }\n    }, 5);\n  });\n};\n\nconst App = ({ container }: { container: Node }) => {\n  const [data, setData] = useState<Card | null>(null);\n\n  useEffect(() => {\n    const showToken = (token: Token, rect: DOMRect) => {\n      setData({ token, rect });\n    };\n    const hideToken = () => setData(null);\n    start({\n      match,\n      showToken,\n      hideToken,\n      className: 'dh-underline',\n      ignoreMutations: [container],\n    });\n  }, [setData, container]);\n\n  const handleNewDOMNode = () => {\n    const div = document.createElement('div');\n    div.innerHTML = 'New DIV element';\n    document.body.appendChild(div);\n  };\n\n  return (\n    <React.Fragment>\n      <button onClick={handleNewDOMNode} style={{ padding: '5px 1em' }}>\n        Add New DOM Node, trigger mutation observer\n      </button>\n      <TokenView data={data} />\n    </React.Fragment>\n  );\n};\n\nconst root = document.createElement('div');\nroot.style.margin = 'margin: 1em auto';\ndocument.body.appendChild(root);\nrender(<App container={root} />, root);\n","import React from 'react';\nimport { render } from 'react-dom';\n\nimport { Highlighter } from './Highlighter';\nimport { HighlighterConfig } from './HighlighterConfig';\nimport { Highlights } from './Highlights';\nimport { Token } from './Token';\n\ninterface StartOptions {\n  /**\n   * Defines what to do when the user mouse hover on a token.\n   * @param token The token.\n   * @param rect The `DOMRect` where the user hovered on.\n   * Note that a token might have more than one `DOMRect`s.\n   * @param event The mouse event.\n   */\n  showToken: (token: Token, rect: DOMRect, event: Event) => void;\n\n  /**\n   * Defines what to do when the user moves mouse out of a token.\n   * @param token The token.\n   * @param rect The `DOMRect` where the user moved mouse out from.\n   * Note that a token might have more than one `DOMRect`s.\n   * @param event The mouse event.\n   */\n  hideToken: (token: Token, rect: DOMRect, event: Event) => void;\n\n  /**\n   * The CSS class name for the highlights container.\n   * Defaults to empty string.\n   */\n  className?: string;\n\n  /**\n   * Throttle updates, update at most once every specified milliseconds.\n   * Defaults to `500`.\n   */\n  throttleUpdates?: number;\n\n  /**\n   * A selector or an array of `Node` that do nothing when they mutate.\n   */\n  ignoreMutations: (string | Node)[];\n}\n\n/**\n * Initialize and start the highlighter.\n */\nexport const start = (\n  options: StartOptions & HighlighterConfig & TextNodeSelector,\n) => {\n  const highlighter = new Highlighter(options);\n  const highlights = document.createElement('highlights');\n  if (options.className) {\n    highlights.setAttribute('class', options.className);\n  }\n  document.body.appendChild(highlights);\n\n  render(\n    <Highlights\n      highlighter={highlighter}\n      throttleUpdates={options.throttleUpdates || 500}\n      onMouseEnterItem={options.showToken}\n      onMouseLeaveItem={options.hideToken}\n      ignoreMutations={[...options.ignoreMutations, highlights]}\n    />,\n    highlights,\n  );\n};\n"],"sourceRoot":""}